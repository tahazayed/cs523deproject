package cs523.bitcoinprice.consumer;

import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;

import java.io.IOException;

public class BitcoinPriceHbaseTable {

    private static final String TABLE_NAME = "bitcoin_price";
    private static final String COLUMN_FAMILY = "price-info";

    private static Connection connection = null;

    static {
        try {
            // Initialize HBase configuration and connection
            Configuration config = HBaseConfiguration.create();
            connection = ConnectionFactory.createConnection(config);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Method to insert BitcoinPrice into HBase
    public static void populateData(BitcoinPrice bitcoinPrice) {
        try (Table table = connection.getTable(TableName.valueOf(TABLE_NAME))) {

            // Create a new row in HBase using assetId as the row key
            Put put = new Put(Bytes.toBytes(bitcoinPrice.getAssetId()));

            // Add columns for the Bitcoin price data
            put.addColumn(Bytes.toBytes(COLUMN_FAMILY), Bytes.toBytes("price"), Bytes.toBytes(bitcoinPrice.getPrice()));
            put.addColumn(Bytes.toBytes(COLUMN_FAMILY), Bytes.toBytes("timestamp"), Bytes.toBytes(bitcoinPrice.getTimestamp()));
            put.addColumn(Bytes.toBytes(COLUMN_FAMILY), Bytes.toBytes("size"), Bytes.toBytes(bitcoinPrice.getSize()));

            // Store the row in the HBase table
            table.put(put);
            System.out.println("Inserted BitcoinPrice into HBase: " + bitcoinPrice);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Close HBase connection when done
    public static void closeConnection() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

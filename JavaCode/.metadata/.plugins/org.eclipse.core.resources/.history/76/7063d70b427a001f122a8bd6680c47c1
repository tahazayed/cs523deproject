package cs523.bitcoinprice.consumer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import kafka.serializer.StringDecoder;



import org.apache.spark.SparkConf;

import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.streaming.Durations;
import org.apache.spark.streaming.api.java.JavaPairInputDStream;
import org.apache.spark.streaming.api.java.JavaStreamingContext;
import org.apache.spark.streaming.kafka.KafkaUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class BitcoinPriceListener {
	private static final Logger logger = LoggerFactory
			.getLogger(BitcoinPriceListener.class);

	// public static void process(JavaPairInputDStream<String, String> stream) {
	// JavaDStream<String> bitcoinPrices = stream.map(ConsumerRecord::value);
	//
	// bitcoinPrices.foreachRDD(rdd -> {
	// rdd.foreach(record -> {
	// try {
	// // Parse the record as JSON using Gson
	// JsonObject jsonObject = new JsonParser().parse(record).getAsJsonObject();
	//
	// // Extract fields from the JSON
	// String assetId = jsonObject.get("assetId").getAsString();
	// double price = jsonObject.get("price").getAsDouble();
	// String timestamp = jsonObject.get("timestamp").getAsString();
	// double size = jsonObject.get("size").getAsDouble();
	//
	// // Log the processed data
	// logger.info("Processed Bitcoin Price: assetId={}, price={}, timestamp={}, size={}",
	// assetId, price, timestamp, size);
	//
	// // Create BitcoinPrice object
	// BitcoinPrice bitcoinPrice = new BitcoinPrice(assetId, price, timestamp,
	// size);
	//
	// // Insert the BitcoinPrice object into HBase
	// BitcoinPriceHbaseTable.populateData(bitcoinPrice);
	//
	// } catch (Exception e) {
	// // Handle JSON parsing error
	// logger.error("Invalid JSON received: " + record, e);
	// }
	// });
	// });
	// }
	//
	/**
	 * @param args
	 * @throws Exception
	 */
	public static void main(String[] args) throws Exception {

		// Configure Spark
		SparkConf conf = new SparkConf().setAppName("BitcoinPriceListener")
				.setMaster("local[*]"); 

		JavaStreamingContext sc = new JavaStreamingContext(conf, Durations.seconds(10));

		// Kafka parameters
		Map<String, String> kafkaParams = new HashMap<>();
		kafkaParams.put("metadata.broker.list", "localhost:9092");
		kafkaParams.put("group.id", "bitcoin-consumer-group");
		kafkaParams.put("auto.offset.reset", "largest");

		Set<String> topics = new HashSet<>(Arrays.asList("bitcoin-price"));

		JavaPairInputDStream<String, String> stream = KafkaUtils
				.createDirectStream(sc, String.class, String.class,
						StringDecoder.class, StringDecoder.class, kafkaParams,
						topics);

		stream.foreachRDD(rdd -> {
		    if (!rdd.isEmpty()) {

		        rdd.foreach(record -> {
		            logger.info("record : " + record);

		            try {
		                // Initialize Gson and JsonParser
		                Gson gson = new Gson();
		                JsonParser jsonParser = new JsonParser();  // JsonParser instance

		                // Parse the record (assuming record._2() is a JSON string)
		                JsonObject jsonObject = jsonParser.parse(record._2()).getAsJsonObject();

		                // Access the data array inside the JSON object
		                JsonArray dataArray = jsonObject.getAsJsonArray("data");

		                // Loop through the data array and extract fields
		                for (int i = 0; i < dataArray.size(); i++) {
		                    JsonObject tradeNode = dataArray.get(i).getAsJsonObject();
		                    String assetId = tradeNode.get("assetId").getAsString();
		                    double price = tradeNode.get("price").getAsDouble();
		                    String timestamp = tradeNode.get("timestamp").getAsString();
		                    double size = tradeNode.get("size").getAsDouble();

		                    // Create a BitcoinPrice object
		                    BitcoinPrice bitcoinPrice = new BitcoinPrice(assetId, price, timestamp, size);

		                    // Populate data in HBase
		                    BitcoinPriceHbaseTable.populateData(bitcoinPrice);
		                }

		            } catch (Exception e) {
		                e.printStackTrace();
		            }
		        });
		    }
		});

		// Start the streaming context and await termination
		sc.start();
		sc.awaitTermination();
	}
}
